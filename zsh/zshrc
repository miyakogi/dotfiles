#!/usr/bin/env zsh
# ============================================
#  Main Config File for ZSH
# ============================================

# profiling
# zmodload zsh/zprof && zprof

########## Key Binding ##########
bindkey -e

# Optional key mappings for zsh
# bindkey "\e[2~" overwrite-mode
bindkey "\e[3~" delete-char
# bindkey "\e[5~" beginning-of-buffer-or-history
# bindkey "\e[6~" end-of-buffer-or-history

if [[ -n $TMUX ]]; then
  bindkey "\e[1~" beginning-of-line
  bindkey "\e[4~" end-of-line
else
  bindkey "\e[H" beginning-of-line
  bindkey "\e[F" end-of-line
fi

########## HISTORY ##########
HISTFILE=~/.histfile
DIRSTACKSIZE=1000
HISTSIZE=1000000
SAVEHIST=1000000
setopt hist_ignore_all_dups
setopt hist_reduce_blanks
setopt share_history
setopt hist_verify
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^P" history-beginning-search-backward-end
bindkey "^N" history-beginning-search-forward-end
setopt noflowcontrol

######### Shell options ##########
setopt correct
setopt auto_cd
# setopt auto_pushd
# setopt pushd_ignore_dups
autoload -Uz add-zsh-hook
autoload -Uz colors && colors
autoload -Uz is-at-least
# autoload predict-on && predict-on
setopt interactivecomments

# Color setting
export LSCOLORS=Exfxcxdxbxegedabagacad
export LS_COLORS='di=01;34:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
export ZLS_COLORS=$LS_COLORS
export CLICOLOR=true

########## COMPLETION ##########
# http://d.hatena.ne.jp/oovu70/20120405/p1
# may not need when use zsh-completions plugin
autoload -Uz compinit && compinit -C
setopt list_packed
setopt list_types

bindkey "^[[Z" reverse-menu-complete
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*:default' menu select=2
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion:*:descriptions' format '%BCompleting%b %U%d%u'
# Colorize completions
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

# Automatically rehash executables on completion
zstyle ':completion:*' rehash true

########## Terminal Tittle ##########
function _title() {
  print -Pn "\e]2;${1:-zsh}\a"
}
if [[ $TERM == (alacritty*|kitty*) ]]; then
  add-zsh-hook -Uz precmd _title
  add-zsh-hook -Uz preexec _title
fi

########## EDIT ##########
# Set keyword
autoload -Uz select-word-style
select-word-style default
# Add word separations (-,/,=,;,@,:,[,],{,},(,),|,',',.)
zstyle ':zle:*' word-chars " -/=;@:[]{}()<>,|.'"
zstyle ':zle:*' word-style unspecified

########## ALIAS ##########
if [[ $XDG_SESSION_TYPE == wayland ]]; then
  # vim's clipboard does not work on wayland
  alias vim=nvim
  export EDITOR=nvim
fi
alias vi="/usr/bin/vim --noplugin"
alias :q="exit"
alias mkdir="mkdir -p"
alias ln="ln -v"  # verbose
if [[ $TERM == (alacritty*|kitty*) ]]; then
  # alacritty/kitty does not correctly handled
  alias ssh="TERM=xterm-256color ssh"
fi
if [[ $TERM == alacritty ]]; then
  # alacritty default $TERM does not support TrueColor on tmux
  alias tmux="TERM=xterm-256color tmux"
fi
alias path='echo $PATH | tr -s ":" "\n"'  # pretty print path

# go to git root by `gg`
function git_root() {
  if git rev-parse --is-inside-work-tree &>/dev/null; then
    cd "$(pwd)/$(git rev-parse --show-cdup)"
  else
    cd ~
  fi
}
alias gg=git_root

# quiet command existance check
function __check_cmd() {
  type $@ &>/dev/null
}

# alias for `ls` command
if __check_cmd exa; then
  if [[ -n $DISPLAY ]]; then
    alias ls="exa --icons"
    alias lsa="exa --icons -a"
  else
    alias ls="exa"
    alias lsa="exa -a"
  fi
elif __check_cmd lsd && [[ -n $DISPLAY ]]; then
  alias ls="lsd"
else
  case "${OSTYPE}" in
  # Mac(Unix)
  darwin*)
    export LS_OPTIONS='-FG' ;;
  # Linux
  linux*)
    export LS_OPTIONS='--color=auto -F' ;;
  # Others (Windows)
  *)
    export LS_OPTIONS='--color=auto' ;;
  esac
  [[ -f ~/.dircolors ]] && eval "$(dircolors ~/.dircolors)"
  alias ls="ls $LS_OPTIONS"
fi

# Colorize man page
# http://boredzo.org/blog/archives/2016-08-15/colorized-man-pages-understood-and-customized
export LESS_TERMCAP_mb=$'\e[1;36m'
export LESS_TERMCAP_md=$'\e[1;36m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[1;44;37m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;32m'

# Git
alias gstatus="git status -s -b"

# python unit test
alias pyunit='python -m unittest discover'

########## Change Directory ##########
# execute ls after cd
chpwd() {
  ls
}

# move up by Ctrl+y
function cd-up {
  zle push-line
  LBUFFER='cd ../'
  zle accept-line
}
zle -N cd-up
bindkey "^Y" cd-up

########## Plugin Settings ##########
# Load file if exists
function load_if_exists() {
  [[ -f $1 ]] && source $1
}

### Node.js virtual env control
export NVM_LAZY_LOAD=true
export NVM_NO_USE=true
load_if_exists $ZDOTDIR/zsh-nvm/zsh-nvm.plugin.zsh

### zsh-completions
# http://www.slideshare.net/mollifier/zsh-3?next_slideshow=1
fpath=($ZDOTDIR/zsh-completions/src(N-/) $fpath)
load_if_exists $ZDOTDIR/git-flow-completion/git-flow-completion.zsh
### zsh-autopair
load_if_exists $ZDOTDIR/zsh-autopair/autopair.zsh

### syntax highlight
if [[ -e /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]]; then  # Arch
  source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
else
  load_if_exists $ZDOTDIR/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
fi
typeset -A ZSH_HIGHLIGHT_STYLES
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern)
ZSH_HIGHLIGHT_STYLES[default]='fg=cyan'
ZSH_HIGHLIGHT_STYLES[builtin]='fg=cyan,bold'
ZSH_HIGHLIGHT_STYLES[command]='fg=cyan,bold'
ZSH_HIGHLIGHT_STYLES[alias]='fg=cyan,bold'
ZSH_HIGHLIGHT_STYLES[function]='fg=cyan,bold'
ZSH_HIGHLIGHT_STYLES[commandseparator]='fg=white,bold'
ZSH_HIGHLIGHT_STYLES[redirection]='fg=white,bold'
ZSH_HIGHLIGHT_STYLES[comment]='fg=#999999'
typeset -A ZSH_HIGHLIGHT_PATTERNS
ZSH_HIGHLIGHT_PATTERNS+=('rm -rf *' 'fg=white,bold,bg=red')
ZSH_HIGHLIGHT_PATTERNS+=('sudo' 'fg=white,bold,bg=red')
ZSH_HIGHLIGHT_PATTERNS+=('sudoedit' 'fg=white,bold,bg=red')

### auto suggestion
if [[ -e /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then  # Arch
  source /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
else
  load_if_exists $ZDOTDIR/zsh-autosuggestions/zsh-autosuggestions.zsh
fi
bindkey '^f' forward-word
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=242"

### pip
# pip zsh completion start
function _pip_completion() {
  local words cword
  read -Ac words
  read -cn cword
  reply=( $( COMP_WORDS="$words[*]" \
             COMP_CWORD=$(( cword-1 )) \
             PIP_AUTO_COMPLETE=1 $words[1] ) )
}
compctl -K _pip_completion pip

function pip-init() {
  # Initialize python virtual environment.
  # This function installs these additional dependencies:
  #   - jedi: auto-completion
  #   - pynvim: required by deoplete.nvim
  #   - nose: required by vim-test
  #   - ptpython: python-shell
  echo -e "\e[36m[pip-init] update pip and setuptools\e[m"
  pip install -U pip setuptools
  echo -e "\n\e[36m[pip-init] install jeid, pynvim, nose, and ptpython\e[m"
  pip install jedi pynvim nose ptpython
  if [[ -e "setup.py" ]]; then
    echo -e "\n\e[36m[pip-init] install this package with editable mode\e[m"
    pip install -e .
  fi
  if [[ -e "requirements-dev.txt" ]]; then
    echo -e "\n\e[36m[pip-init] install dev requirements\e[m"
    pip install -r "requirements-dev.txt"
  elif [[ -e "requirements.txt" ]]; then
    echo -e "\n\e[36m[pip-init] install project requirements\e[m"
    pip install -r "requirements.txt"
  fi
}

### skim
export SKIM_DEFAULT_COMMAND="fd --type f || git ls-tree -r --name-only HEAD || rg --files || find ."
if __check_cmd sk && [[ $OSTYPE != msys ]]; then
  export HIST_DIRS_FILE=$HOME/.histdir
  export HIST_DIRS_MAX=1000
  function cdhist() {
    local curdir=$(pwd | sed -e "s|$HOME|\$HOME|" -e "s|$USER|\$USER|")
    local tmphist=$({ grep -v -x "$curdir" "$HIST_DIRS_FILE"; echo "$curdir" } | tail -n $HIST_DIRS_MAX)
    echo $tmphist >$HIST_DIRS_FILE
  }
  add-zsh-hook chpwd cdhist

  local cmd='sk --tac --no-sort --reverse --exact --tiebreak index --prompt "skim>" --margin 2% --query "$BUFFER"'

  function search-history() {
    BUFFER=$(history -n 1 | eval ${cmd})
    CURSOR=$#BUFFER
    zle -R -c
  }
  zle -N search-history
  bindkey '^R' search-history

  function myjump() {
    local destination=$([[ -e $HIST_DIRS_FILE ]] && cat $HIST_DIRS_FILE | eval ${cmd})
    [[ -n "$destination" ]] && BUFFER="cd \"$destination\"" && zle accept-line
    zle reset-prompt
  }
else
  # if skim is not available, use zaw and cdr
  # very slow...
  # http://yagays.github.io/blog/2013/05/20/zaw-zsh/
  # Save cd history
  autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
  add-zsh-hook chpwd chpwd_recent_dirs
  zstyle ':chpwd:*' recent-dirs-max 5000
  zstyle ':chpwd:*' recent-dirs-default yes
  zstyle ':completion:*' recent-dirs-insert both

  load_if_exists $ZDOTDIR/zaw/zaw.zsh
  zstyle ':filter-select' case-insensitive yes # case-insensitive matching
  bindkey '^R' zaw-history # zaw-historyã‚’bindkey

  function myjump() { zaw-cdr }
fi

zle -N myjump
if [ $DOLPHIN ]; then
  bindkey '^L' myjump
elif [ $VIM ]; then
  bindkey '^L' myjump
else
  bindkey '^J' myjump
fi

function mkpjpy() {
  [[ -z $1 ]] && echo "Need project name." && return 1
  local pjdir_root=${PROJECT_HOME:-$HOME/Projects}
  local pjdir=${pjdir_root}/$1
  [[ -e $pjdir ]] && echo "Target project ${pjdir} already exists." && return 1

  # make new project by cookiecutter
  echo "### Create project directory by cookiecutter ###"
  local cookierc=${HOME}/.cookiecutterrc
  cookiecutter --config-file ${cookierc} --no-input -o ${pjdir_root} cookiecutter-python \
    project_name=${1} project_slug=${1} \
    project_short_description="short description for this project" \
    version="0.0.1" license="MIT license"

  [[ ! -e $pjdir ]] && echo "Failed to make new project." && return 1
  cd $pjdir
}

### direnv
if __check_cmd direnv; then
  eval "$(direnv hook zsh)"
fi

### prompt
if [[ -n $DISPLAY ]] && __check_cmd starship; then
  # use starship prompt in graphical session
  eval "$(starship init zsh)"
else
  # use my prompt on TTY
  load_if_exists $ZDOTDIR/prompt.zsh
fi

### load machine local file
[[ -f $ZDOTDIR/.zshrc.local ]] && source $ZDOTDIR/.zshrc.local

### profiling
if (__check_cmd zprof) ; then
  zprof
fi

# vim: set et ts=2 sw=2:
