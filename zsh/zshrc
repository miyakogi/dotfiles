#!/usr/bin/env zsh
# ============================================
#  Main Config File for ZSH
# ============================================

########## Key Binding ##########
bindkey -e

# Optional key mappings for zsh
# bindkey "\e[2~" overwrite-mode
bindkey "\e[3~" delete-char
# bindkey "\e[5~" beginning-of-buffer-or-history
# bindkey "\e[6~" end-of-buffer-or-history

if [[ -n $TMUX ]]; then
  bindkey "\e[1~" beginning-of-line
  bindkey "\e[4~" end-of-line
else
  bindkey "\e[H" beginning-of-line
  bindkey "\e[F" end-of-line
fi

########## HISTORY ##########
HISTFILE=~/.histfile
DIRSTACKSIZE=1000
HISTSIZE=1000000
SAVEHIST=1000000
setopt hist_ignore_all_dups
setopt hist_reduce_blanks
setopt share_history
setopt hist_verify
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^P" history-beginning-search-backward-end
bindkey "^N" history-beginning-search-forward-end
setopt noflowcontrol

######### Shell options ##########
setopt correct
setopt auto_cd
# setopt auto_pushd
# setopt pushd_ignore_dups
autoload -Uz add-zsh-hook
autoload -Uz colors && colors
autoload -Uz is-at-least
# autoload predict-on && predict-on

# Color setting
export LSCOLORS=Exfxcxdxbxegedabagacad
export LS_COLORS='di=01;34:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
export ZLS_COLORS=$LS_COLORS
export CLICOLOR=true

########## COMPLETION ##########
# http://d.hatena.ne.jp/oovu70/20120405/p1
# may not need when use zsh-completions plugin
autoload -Uz compinit && compinit -C
setopt list_packed
setopt list_types

bindkey "^[[Z" reverse-menu-complete
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*:default' menu select=2
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion:*:descriptions' format '%BCompleting%b %U%d%u'
# Colorize completions
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

# Automatically rehash executables on completion
zstyle ':completion:*' rehash true

########## EDIT ##########
# Set keyword
autoload -Uz select-word-style
select-word-style default
# Add word separations (-,/,=,;,@,:,{,},|,',')
zstyle ':zle:*' word-chars " -/=;@:{},|"
zstyle ':zle:*' word-style unspecified

########## ALIAS ##########
alias vi="/usr/bin/vim --noplugin"
alias :q="exit"
alias tmux="tmux -2"
alias mkdir="mkdir -p"
alias ln="ln -v"  # verbose
alias path='echo $PATH | tr -s ":" "\n"'  # pretty print path
alias gg='cd `echo ${PROJECT_ROOT:-$HOME}`'

# alias for `ls` command
if which exa >/dev/null; then
  alias ls="exa"
else
  case "${OSTYPE}" in
  # Mac(Unix)
  darwin*)
    export LS_OPTIONS='-FG' ;;
  # Linux
  linux*)
    export LS_OPTIONS='--color=auto -F' ;;
  # Others (Windows)
  *)
    export LS_OPTIONS='--color=auto' ;;
  esac
  [[ -f ~/.dircolors ]] && eval "`dircolors ~/.dircolors`"
  alias ls="ls $LS_OPTIONS"
fi

# alias for `cat` command
if which bat >/dev/null; then
  alias cat=bat
fi

# Colorize man page
# http://boredzo.org/blog/archives/2016-08-15/colorized-man-pages-understood-and-customized
function man() {
  env \
    LESS_TERMCAP_mb=$'\e[1;36m' \
    LESS_TERMCAP_md=$'\e[1;36m' \
    LESS_TERMCAP_me=$'\e[0m' \
    LESS_TERMCAP_se=$'\e[0m' \
    LESS_TERMCAP_so=$'\e[1;44;37m' \
    LESS_TERMCAP_ue=$'\e[0m' \
    LESS_TERMCAP_us=$'\e[1;32m' \
    man "$@"
}

# Git
alias gstatus="git status -s -b"
alias pull="git pull"
alias push="git push origin"

# python unit test
alias pyunit='python -m unittest discover'

########## Change Directory ##########
# execute ls after cd
chpwd() {
  ls
}

# move up by Ctrl+y
function cd-up {
  zle push-line
  LBUFFER='cd ../'
  zle accept-line
}
zle -N cd-up
bindkey "^Y" cd-up

########## Plugin Settings ##########
# Load file if exists
function load_if_exists() {
  [[ -f $1 ]] && source $1
}

### Python Virtualenv Control
if [[ $OSNAME == Ubuntu ]]; then
  # virtualenvwrapper
  if [[ -f "$HOME/.local/bin/virtualenvwrapper.sh" ]]; then
    export VIRTUALENVWRAPPER_SCRIPT="$HOME/.local/bin/virtualenvwrapper.sh"
    load_if_exists "$HOME/.local/bin/virtualenvwrapper_lazy.sh"
  else
    export VIRTUALENVWRAPPER_SCRIPT=/usr/share/virtualenvwrapper/virtualenvwrapper.sh
    load_if_exists /usr/share/virtualenvwrapper/virtualenvwrapper_lazy.sh
  fi
elif [[ $OSNAME == Mac ]]; then
  # virtualenvwrapper
  export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3
  load_if_exists $HOME/Library/Python/3.7/bin/virtualenvwrapper_lazy.sh
else
  export VIRTUALENVWRAPPER_SCRIPT=/usr/bin/virtualenvwrapper.sh
  load_if_exists /usr/bin/virtualenvwrapper_lazy.sh
fi

### prompt
load_if_exists $ZDOTDIR/prompt

### zsh-completions
# http://www.slideshare.net/mollifier/zsh-3?next_slideshow=1
fpath=($HOME/.zsh/zsh-completions/src(N-/) $fpath)
load_if_exists $ZDOTDIR/git-flow-completion/git-flow-completion.zsh
### zsh-autoenv
load_if_exists $ZDOTDIR/zsh-autoenv/autoenv.zsh
### syntax highlight
# load_if_exists $ZDOTDIR/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

### pip
# pip zsh completion start
function _pip_completion {
  local words cword
  read -Ac words
  read -cn cword
  reply=( $( COMP_WORDS="$words[*]" \
             COMP_CWORD=$(( cword-1 )) \
             PIP_AUTO_COMPLETE=1 $words[1] ) )
}
compctl -K _pip_completion pip

function pip-init {
  # Initialize python virtual environment.
  # This function installs these additional dependencies:
  #   - jedi: auto-completion
  #   - neovim: required by deoplete.nvim
  #   - nose: required by vim-test
  #   - ptpython: python-shell
  echo -e "\e[36m[pip-init] update pip and setuptools\e[m"
  pip install -U pip setuptools
  echo -e "\n\e[36m[pip-init] install jeid, neovim, nose, and ptpython\e[m"
  pip install jedi neovim nose ptpython
  if [[ -e "setup.py" ]]; then
    echo -e "\n\e[36m[pip-init] install this package with editable mode\e[m"
    pip install -e .
  fi
  if [[ -e "requirements-dev.txt" ]]; then
    echo -e "\n\e[36m[pip-init] install dev requirements\e[m"
    pip install -r "requirements-dev.txt"
  fi
}

### percol
if which percol > /dev/null && [[ $OSTYPE != msys ]]; then
  export HIST_DIRS_FILE=$HOME/.histdir
  export HIST_DIRS_MAX=5000
  function cdhist() {
    python << EOS
from os import path
curdir = path.abspath('.') + '\n'
with open('${HIST_DIRS_FILE}', 'r') as f:
    lines = f.readlines()
if len(lines) > ${HIST_DIRS_MAX}:
    lines = lines[-${HIST_DIRS_MAX}:]
while curdir in lines:
    lines.remove(curdir)
lines.append(curdir)
with open('${HIST_DIRS_FILE}', 'w') as f:
    f.write(''.join(lines))
EOS
  }
  add-zsh-hook chpwd cdhist

  local percol_cmd='percol --reverse --query "$LBUFFER"'
  function percol-search-history() {
    BUFFER=$(history -n 1 | eval ${percol_cmd})
    CURSOR=$#BUFFER
    zle -R -c
  }
  zle -N percol-search-history
  bindkey '^R' percol-search-history

  function myjump() {
    local destination=$([[ -e $HIST_DIRS_FILE ]] && cat $HIST_DIRS_FILE | eval ${percol_cmd})
    [[ -n "$destination" ]] && zle -U "cd \"$destination\""
    zle reset-prompt
  }
else
  # percol is not available, use zaw and cdr
  # very slow...
  # http://yagays.github.io/blog/2013/05/20/zaw-zsh/
  # Save cd history
  autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
  add-zsh-hook chpwd chpwd_recent_dirs
  zstyle ':chpwd:*' recent-dirs-max 5000
  zstyle ':chpwd:*' recent-dirs-default yes
  zstyle ':completion:*' recent-dirs-insert both

  load_if_exists $ZDOTDIR/zaw/zaw.zsh
  zstyle ':filter-select' case-insensitive yes # case-insensitive matching
  bindkey '^R' zaw-history # zaw-historyã‚’bindkey

  function myjump() { zaw-cdr }
fi

zle -N myjump
if [ $DOLPHIN ]; then
  bindkey '^L' myjump
elif [ $VIM ]; then
  bindkey '^L' myjump
else
  bindkey '^J' myjump
fi

function mkpjpy() {
  [[ -z $1 ]] && echo "Need project name." && return 1
  local pjdir_root=${PROJECT_HOME:-$HOME/Project}
  local pjdir=${pjdir_root}/$1
  [[ -e $pjdir ]] && echo "Target project ${pjdir} already exists." && return 1

  # make new project by cookiecutter
  echo "### Create project directory by cookiecutter ###"
  local cookierc=${HOME}/.cookiecutterrc
  cookiecutter --config-file ${cookierc} --no-input -o ${pjdir_root} cookiecutter-python \
    project_name=${1} project_slug=${1} \
    project_short_description="short description for this project" \
    version="0.0.1" license="MIT license"

  [[ ! -e $pjdir ]] && echo "Failed to make new project." && return 1
  cd $pjdir
}

# load machine local file
[[ -f $ZDOTDIR/.zshrc.local ]] && source $ZDOTDIR/.zshrc.local

# profiling
if (which zprof > /dev/null) ; then
  zprof
fi

# vim: set et ts=2 sw=2:
