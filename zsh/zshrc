#!/usr/bin/env zsh
# ============================================
#  Main Config File for ZSH
# ============================================

########## HISTORY ##########
HISTFILE=~/.histfile
DIRSTACKSIZE=1000
HISTSIZE=1000000
SAVEHIST=1000000
setopt hist_ignore_all_dups
setopt hist_reduce_blanks
setopt share_history
bindkey -e
setopt hist_verify
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^P" history-beginning-search-backward-end
bindkey "^N" history-beginning-search-forward-end
setopt noflowcontrol

######### Shell options ##########
setopt correct
setopt auto_cd
# setopt auto_pushd
# setopt pushd_ignore_dups
autoload -Uz add-zsh-hook
autoload -Uz colors && colors
autoload -Uz is-at-least
# autoload predict-on && predict-on

# Ëâ≤Ë®≠ÂÆö
export LSCOLORS=Exfxcxdxbxegedabagacad
export LS_COLORS='di=01;34:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
export ZLS_COLORS=$LS_COLORS
export CLICOLOR=true

########## COMPLETION ##########
# http://d.hatena.ne.jp/oovu70/20120405/p1
# may not need when use zsh-completions plugin
autoload -Uz compinit && compinit -C
setopt list_packed
setopt list_types

bindkey "^[[Z" reverse-menu-complete
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*:default' menu select=2
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion:*:descriptions' format '%BCompleting%b %U%d%u'
# Ë£úÂÆåÂÄôË£ú„Å´Ëâ≤„Çí„Å§„Åë„Çã
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

########## EDIT ##########
# Set keyword
autoload -Uz select-word-style
select-word-style default
# Add word separations (-,/,=,;,@,:,{,},|,',')
zstyle ':zle:*' word-chars " -/=;@:{},|"
zstyle ':zle:*' word-style unspecified

########## ALIAS ##########
alias vi="/usr/bin/vim --noplugin"
alias :q="exit"
alias tmux="tmux -2"
alias mkdir="mkdir -p"
alias ln="ln -v"  # verbose
alias path='echo $PATH | tr -s ":" "\n"'  # pretty print path
alias gg='cd `echo ${PROJECT_ROOT:-$HOME}`'

# alias for `ls` command
if which exa >/dev/null; then
  alias ls="exa"
else
  case "${OSTYPE}" in
  # Mac(Unix)
  darwin*)
    export LS_OPTIONS='-FG' ;;
  # Linux
  linux*)
    export LS_OPTIONS='--color=auto -F' ;;
  # Others (Windows)
  *)
    export LS_OPTIONS='--color=auto' ;;
  esac
  [[ -f ~/.dircolors ]] && eval "`dircolors ~/.dircolors`"
  alias ls="ls $LS_OPTIONS"
fi

# alias for `cat` command
if which bat >/dev/null; then
  alias cat=bat
fi

# Git
alias gstatus="git status -s -b"
alias pull="git pull"
alias push="git push origin"

########## PROMPT ##########
### Normal PROMPT
if [[ $OSNAME == Windows ]]; then
  PROMPT_SIMPLE_MODE=0
elif [[ -n $DISPLAY ]]; then
  PROMPT_SIMPLE_MODE=0
else
  PROMPT_SIMPLE_MODE=1
fi
BR=$'\n'

### set icon
# local icon="üêß"  # penguin
# local icon=$'\uf17c '  # tux ÔÖº
if [[ $OSNAME == Mac ]]; then
  _icon=$'\ue711 '  # mac Óúë
elif [[ $OSNAME == Windows ]]; then
  _icon='‚ùñ '
elif [[ $OSNAME == Ubuntu ]]; then
  _icon=$'\uf30c '  # ubuntu Ôåå
elif [[ $OSNAME == Arch ]]; then
  _icon=$'\uf300 '  # Arch ÔåÄ
else  # other linux
  _icon=$'\uf17c '  # tux ÔÖº
fi

_icon_sep=$'\ue621'  # separator Óò°
if [[ $OSNAME == Windows ]]; then
  _mark="$ "
else
  _mark="‚îî‚îÄ‚ñ∂ "
fi
_icon_color="%F{16}%(?,%K{green},%K{yellow})"
_icon_dash="%K{16}%(?,%F{green},%F{yellow}) "
# _icon_dash="%K{16}%(?,%F{green},%F{yellow})"$'\ue0b8 '

### configure lprompt
function _update_lprompt() {
  [[ $PROMPT_SIMPLE_MODE == 1 ]] && PROMPT="[%~]$BR$ " && return
  _cols=`tput cols`
  if [[ $OSNAME == Windows ]] && [[ $TERM != cygwin ]]; then
    _cols=$(($_cols / 2))
  fi
  _sep=`repeat $_cols printf ‚îÄ`
  _separator="%F{238}$_sep%f"

  if [[ -n "$VIRTUAL_ENV" ]]; then
    # local icon=$'\ue235 '  # python Óàµ
    local icon="üêç"  # snake
    if [[ $OSTYPE = darwin* ]]; then
      local icon="${icon} "
    fi
    local icon="$icon$_icon_sep$(basename $VIRTUAL_ENV) "
  else
    local icon=$_icon
  fi

  if [ -n "${REMOTEHOST}${SSH_CONNECTION}" ]; then
    local ssh_icon=$'\uf023'  # ÔÄ£
    local icon="$ssh_icon $_icon_sep $icon "
  fi

  local mark="%(?,%F{green}$_mark%f,%F{yellow}$_mark%f)%(!,#,)"
  PROMPT="$_separator$BR$_icon_color $icon$_icon_dash%F{250}%~ %k$BR$mark"
}

### RPROMPT
### get vcs info
autoload -Uz vcs_info
zstyle ':vcs_info:*' max-exports 3
zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' formats "%u%cÓÇ† %s:%b ‚îÇ%r"
zstyle ':vcs_info:*' actionformats "%u%cÓÇ† %s:%b%F{198} %m <!%a>"
zstyle ':vcs_info:*' unstagedstr "%F{214}?"
zstyle ':vcs_info:*' stagedstr "%F{087}+"
zstyle ':vcs_info:git:*' check-for-changes true
# zstyle ':vcs_info:hg:*' check-for-changes true

function _get_vcs_info() {
  # vcs_info „Åß‰Ωï„ÇÇÂèñÂæó„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Éó„É≠„É≥„Éó„Éà„ÇíË°®Á§∫„Åó„Å™„ÅÑ
  [[ -z ${vcs_info_msg_0_} ]] && return 0

  # vcs_info „ÅßÊÉÖÂ†±„ÇíÂèñÂæó„Åó„ÅüÂ†¥Âêà
  # $vcs_info_msg_0_ , $vcs_info_msg_1_ , $vcs_info_msg_2_ „Çí
  # „Åù„Çå„Åû„ÇåË°®Á§∫„Åô„Çã
  local -a messages
  [[ -n "$vcs_info_msg_0_" ]] && messages+=( "%F{white}${vcs_info_msg_0_}" )
  [[ -n "$vcs_info_msg_1_" ]] && messages+=( "%F{yellow}${vcs_info_msg_1_}" )
  [[ -n "$vcs_info_msg_2_" ]] && messages+=( "%F{red}${vcs_info_msg_2_}" )
  # Èñì„Å´„Çπ„Éö„Éº„Çπ„ÇíÂÖ•„Çå„Å¶ÈÄ£Áµê„Åó„Å¶Ê®ôÊ∫ñÂá∫Âäõ„Å∏
  echo -n ${messages[*]}
}

function _get_time() {
  local time=`date "+%H:%M:%S"$'\ue621'"%Y/%m/%d"`
  echo "$time"
}

### configure rprompt
function _update_rprompt() {
  [[ $PROMPT_SIMPLE_MODE = 1 ]] && RPROMPT="" && return
  LANG=en_US.UTF-8 vcs_info
  local gitinfo=`_get_vcs_info`
  if [[ -n ${gitinfo} ]]; then
    local rinfo=${gitinfo}
  else
    local rinfo="%F{250}`_get_time`"
  fi
  # RPROMPT="%F{016}"$'\ue0b2'"%K{016} ${rinfo} %f%k"
  RPROMPT="%K{016} ${rinfo} %f%k"
}

# Delete RPROMPT after commands
# setopt transient_rprompt
function _reupdate_rprompt() {
  if [[ $PROMPT_SIMPLE_MODE = 1 ]]; then
    # cannot early return
    RPROMPT=""
  else
    RPROMPT="%F{246}%K{234} `_get_time` %f%k"
  fi
  zle .accept-line
  zle .reset-prompt
}
# show datetime at old line
zle -N accept-line _reupdate_rprompt

function _update_prompt() {
  _update_lprompt
  _update_rprompt
}

function prompt_simple() {
  PROMPT_SIMPLE_MODE=1
}

function prompt_fancy() {
  PROMPT_SIMPLE_MODE=0
}

### Enable prompt
add-zsh-hook precmd _update_prompt

# powerline (python)
# source $HOME/opt/python-3.6.2/lib/python3.6/site-packages/powerline/bindings/zsh/powerline.zsh

########## SYSTEM VARIABLES ##########
# For vim
# export COLORFGBG="15;0"

# Load file if exists
function load_if_exists() {
  [[ -f $1 ]] && source $1
}

########## Plugin Settings ##########
### zsh-completions
# http://www.slideshare.net/mollifier/zsh-3?next_slideshow=1
fpath=($HOME/.zsh/zsh-completions/src(N-/) $fpath)
load_if_exists $ZDOTDIR/git-flow-completion/git-flow-completion.zsh
### zsh-autoenv
load_if_exists $ZDOTDIR/zsh-autoenv/autoenv.zsh
### syntax highlight
# load_if_exists $ZDOTDIR/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

### pip
# pip zsh completion start
function _pip_completion {
  local words cword
  read -Ac words
  read -cn cword
  reply=( $( COMP_WORDS="$words[*]" \
             COMP_CWORD=$(( cword-1 )) \
             PIP_AUTO_COMPLETE=1 $words[1] ) )
}
compctl -K _pip_completion pip

### PythonZ
# Use only on ubuntu
if [[ $OSNAME == Ubuntu ]]; then
  load_if_exists $HOME/.pythonz/etc/bashrc
fi

### direnv
# which direnv > /dev/null && eval "$(direnv hook zsh)"

### percol
if which percol > /dev/null && [[ $OSTYPE != msys ]]; then
  export HIST_DIRS_FILE=$HOME/.histdir
  export HIST_DIRS_MAX=5000
  function cdhist() {
    python << EOS
from os import path
curdir = path.abspath('.') + '\n'
with open('${HIST_DIRS_FILE}', 'r') as f:
    lines = f.readlines()
if len(lines) > ${HIST_DIRS_MAX}:
    lines = lines[-${HIST_DIRS_MAX}:]
while curdir in lines:
    lines.remove(curdir)
lines.append(curdir)
with open('${HIST_DIRS_FILE}', 'w') as f:
    f.write(''.join(lines))
EOS
  }
  add-zsh-hook chpwd cdhist

  local percol_cmd='percol --reverse --query "$LBUFFER"'
  function percol-search-history() {
    BUFFER=$(history -n 1 | eval ${percol_cmd})
    CURSOR=$#BUFFER
    zle -R -c
  }
  zle -N percol-search-history
  bindkey '^R' percol-search-history

  function myjump() {
    local destination=$([[ -e $HIST_DIRS_FILE ]] && cat $HIST_DIRS_FILE | eval ${percol_cmd})
    [[ -n "$destination" ]] && zle -U "cd \"$destination\""
    zle reset-prompt
  }
else
  # percol is not available, use zaw and cdr
  # very slow...
  # http://yagays.github.io/blog/2013/05/20/zaw-zsh/
  # Save cd history
  autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
  add-zsh-hook chpwd chpwd_recent_dirs
  zstyle ':chpwd:*' recent-dirs-max 5000
  zstyle ':chpwd:*' recent-dirs-default yes
  zstyle ':completion:*' recent-dirs-insert both

  load_if_exists $ZDOTDIR/zaw/zaw.zsh
  zstyle ':filter-select' case-insensitive yes # Áµû„ÇäËæº„Åø„Çícase-insensitive„Å´
  bindkey '^R' zaw-history # zaw-history„Çíbindkey

  function myjump() { zaw-cdr }
fi

zle -N myjump
if [ $DOLPHIN ]; then
  bindkey '^L' myjump
elif [ $VIM ]; then
  bindkey '^L' myjump
else
  bindkey '^J' myjump
fi

### Python Virtualenv Control ###
if [[ $OSNAME == Ubuntu ]]; then
  export VIRTUALWRAPPER_SCRIPT=$HOME/opt/python-3.6.2/bin/virtualenvwrapper.sh
  load_if_exists $HOME/opt/python-3.6.2/bin/virtualenvwrapper_lazy.sh
elif [[ $OSNAME == Windows ]]; then
  # On windows fials to load lazy script
  load_if_exists /usr/bin/virtualenvwrapper.sh
  if [[ $TERM != cygwin ]]; then
    export VIRTUALENV_PYTHON=/usr/bin/python3
  fi
else
  export VIRTUALWRAPPER_SCRIPT=/usr/bin/virtualenvwrapper.sh
  load_if_exists /usr/bin/virtualenvwrapper_lazy.sh
fi

function mkpjpy() {
  [[ -z $1 ]] && echo "Need project name." && return 1
  local pjdir_root=${PROJECT_HOME:-$HOME/Project}
  local pjdir=${pjdir_root}/$1
  [[ -e $pjdir ]] && echo "Target project ${pjdir} already exists." && return 1

  # make new project by cookiecutter
  echo "### Create project directory by cookiecutter ###"
  local cookierc=${HOME}/.cookiecutterrc
  cookiecutter --config-file ${cookierc} --no-input -o ${pjdir_root} cookiecutter-python \
    project_name=${1} project_slug=${1} \
    project_short_description="short description for this project" \
    version="0.0.1" license="MIT license"

  [[ ! -e $pjdir ]] && echo "Failed to make new project." && return 1
  cd $pjdir
}

# load machine local file
[[ -f $ZDOTDIR/.zshrc.local ]] && source $ZDOTDIR/.zshrc.local

# profiling
if (which zprof > /dev/null) ; then
  zprof
fi

# vim: set et ts=2 sw=2:
