#!/usr/bin/zsh
# ============================================
#  Main Config File for ZSH
# ============================================

########## HISTORY ##########
HISTFILE=~/.histfile
DIRSTACKSIZE=1000
HISTSIZE=1000000
SAVEHIST=1000000
setopt hist_ignore_all_dups
setopt hist_reduce_blanks
setopt share_history
bindkey -e
setopt hist_verify
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^P" history-beginning-search-backward-end
bindkey "^N" history-beginning-search-forward-end
setopt noflowcontrol

######### Shell options ##########
setopt correct
setopt auto_cd
# setopt auto_pushd
# setopt pushd_ignore_dups
autoload -Uz add-zsh-hook
autoload -Uz colors && colors
# autoload -U colors && colors
autoload -Uz is-at-least
# autoload predict-on
# predict-on

# Ëâ≤Ë®≠ÂÆö
export LSCOLORS=Exfxcxdxbxegedabagacad
export LS_COLORS='di=01;34:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
export ZLS_COLORS=$LS_COLORS
export CLICOLOR=true

########## COMPLETION ##########
# http://d.hatena.ne.jp/oovu70/20120405/p1
autoload -Uz compinit && compinit -C
setopt list_packed
setopt list_types

bindkey "^[[Z" reverse-menu-complete
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*:default' menu select=2
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion:*:descriptions' format '%BCompleting%b %U%d%u'
# Ë£úÂÆåÂÄôË£ú„Å´Ëâ≤„Çí„Å§„Åë„Çã
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

########## EDIT ##########
# Set keyword
autoload -Uz select-word-style
select-word-style default
# Add word separations (-,/,=,;,@,:,{,},|,',')
zstyle ':zle:*' word-chars " -/=;@:{},|"
zstyle ':zle:*' word-style unspecified

########## ALIAS ##########
alias vi="/usr/bin/vim --noplugin"
alias :q="exit"
alias tmux="tmux -2"

case "${OSTYPE}" in
# Mac(Unix)
darwin*)
  export LS_OPTIONS='-xFG' ;;
# Linux
linux*)
  export LS_OPTIONS='--color=auto -xF' ;;
esac
[[ -f ~/.dircolors ]] && eval "`dircolors ~/.dircolors`"
alias ls="ls $LS_OPTIONS"

# . ~/.vim/bundle/powerline/powerline/bindings/zsh/powerline.zsh
# ZSH_THEME="powerline"
alias gstatus="git status -s -b"
# http://qiita.com/syui/items/ed2d36698a5cc314557d

######### VCS information ###########
# http://qiita.com/mollifier/items/8d5a627d773758dd8078
autoload -Uz vcs_info
zstyle ':vcs_info:*' max-exports 3
zstyle ':vcs_info:*' enable git hg
zstyle ':vcs_info:*' formats '%c%uÓÇ† %s:%b‚îÇ%r'
zstyle ':vcs_info:*' actionformats '%c%uÓÇ† %s:%b %m <!%a>'
zstyle ':vcs_info:*' unstagedstr '?'
zstyle ':vcs_info:*' stagedstr '+'
zstyle ':vcs_info:git:*' check-for-changes true
zstyle ':vcs_info:hg:*' check-for-changes true

function _get_vcs_info() {
  # vcs_info „Åß‰Ωï„ÇÇÂèñÂæó„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Éó„É≠„É≥„Éó„Éà„ÇíË°®Á§∫„Åó„Å™„ÅÑ
  [[ -z ${vcs_info_msg_0_} ]] && return 0

  # vcs_info „ÅßÊÉÖÂ†±„ÇíÂèñÂæó„Åó„ÅüÂ†¥Âêà
  # $vcs_info_msg_0_ , $vcs_info_msg_1_ , $vcs_info_msg_2_ „Çí
  # „Åù„Çå„Åû„ÇåÁ∑ë„ÄÅÈªÑËâ≤„ÄÅËµ§„ÅßË°®Á§∫„Åô„Çã
  local -a messages
  [[ -n "$vcs_info_msg_0_" ]] && messages+=( "%F{cyan}${vcs_info_msg_0_}%f" )
  [[ -n "$vcs_info_msg_1_" ]] && messages+=( "%F{yellow}${vcs_info_msg_1_}%f" )
  [[ -n "$vcs_info_msg_2_" ]] && messages+=( "%F{red}${vcs_info_msg_2_}%f" )
  # Èñì„Å´„Çπ„Éö„Éº„Çπ„ÇíÂÖ•„Çå„Å¶ÈÄ£Áµê„Åó„Å¶Ê®ôÊ∫ñÂá∫Èå≤„Å∏
  echo -n "${messages[*]}"
}

########## PROMPT ##########
### Normal PROMPT
SIMPLE_PROMPT_MODE=0
function _update_lprompt() {
  if [ $SIMPLE_PROMPT_MODE = 1 ]; then
    PROMPT=">>> "
    return 0
  fi
  local p_base_ok_ssh="%F{blue}%n@${HOST}%f"
  local p_base_ng_ssh="%F{magenta}%n@${HOST}%f"
  # local p_base_ng_ssh="%{[38;5;222m%}%n@${HOST}%{[m%}"

  local p_cdir="%{[38;5;246m%}[%/]%{[m%}"
  local p_cdir_ssh="%(?,$p_base_ok_ssh ,$p_base_ng_ssh )%(!,#,)%{[38;5;252m%}[%/]%{[m%}"
  local p_err_mark="%{[38;5;124m%}‚úò %{[m%}"
  local p_cdir="$p_cdir%(?,,$p_err_mark)%(!,#,)"
  local p_cdir_ssh="$p_cdir_ssh%(?,,$p_err_mark)%(!,#,)"

  local p_br=$'\n'
  local p_mark_ok="%F{green}>>>%f"
  local p_mark_ok_ssh="%F{blue}>>>%f"
  local p_mark_ng="%F{yellow}>>>%f"
  local p_mark_ng_ssh="%F{magenta}>>>%f"
  local p_mark="%B%(?,$p_mark_ok,$p_mark_ng)%(!,#,)%b"
  local p_mark_ssh="%B%(?,$p_mark_ok_ssh,$p_mark_ng_ssh)%(!,#,)%b"

  if [ -n "${REMOTEHOST}${SSH_CONNECTION}" ]
  then PROMPT="$p_br$p_cdir_ssh$p_br$p_mark_ssh "
  else PROMPT="$p_br$p_cdir$p_br$p_mark "
  fi
}

### RPROMPT
# Delete RPROMPT after commands
setopt transient_rprompt
function _update_rprompt() {
  if [ $SIMPLE_PROMPT_MODE = 1 ]; then
    RPROMPT=""
    return
  fi
  LANG=en_US.UTF-8 vcs_info
  RPROMPT=`_get_vcs_info`
}

function _update_prompt() {
  _update_lprompt
  _update_rprompt
}
add-zsh-hook precmd _update_rprompt
_update_prompt

function simple_prompt() {
  SIMPLE_PROMPT_MODE=1
  _update_prompt
  _update_vcs_info_msg
}
[[ $VIM ]] && simple_prompt

########## SYSTEM VARIABLES ##########
# For vim
# export COLORFGBG="15;0"

# Load file if exists
function load_if_exists() {
  [[ -f $1 ]] && source $1
}

########## PythonZ ##########
load_if_exists $HOME/.pythonz/etc/bashrc

########## direnv ##########
which direnv > /dev/null && eval "$(direnv hook zsh)"

########## Plugin Settings ##########
### zsh-completions
# http://www.slideshare.net/mollifier/zsh-3?next_slideshow=1
fpath=($HOME/.zsh/zsh-completions/src(N-/) $fpath)
load_if_exists $ZDOTDIR/git-flow-completion/git-flow-completion.zsh
### zsh-autoenv
load_if_exists $ZDOTDIR/zsh-autoenv/autoenv.zsh
### syntax highlight
# load_if_exists $ZDOTDIR/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# „Å®„Å¶„ÇÇÈÅÖ„ÅÑ„ÄÇ„ÄÇ„ÄÇ
# http://yagays.github.io/blog/2013/05/20/zaw-zsh/
# Save cd history
# autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
# add-zsh-hook chpwd chpwd_recent_dirs
# zstyle ':chpwd:*' recent-dirs-max 5000
# zstyle ':chpwd:*' recent-dirs-default yes
# zstyle ':completion:*' recent-dirs-insert both
export HIST_DIRS_FILE=$HOME/.histdir
export HIST_DIRS_MAX=5000

if which rireki > /dev/null 2>&1 && rireki status > /dev/null 2>&1
then
  # echo "use rireki server"
  function cdhist() {
    pwd >> $HIST_DIRS_FILE
  }
else
  # echo "rireki server is not running"
  function cdhist() {
    python << EOS
from os import path
curdir = path.abspath('.') + '\n'
if path.isfile('${HIST_DIRS_FILE}'):
    with open('${HIST_DIRS_FILE}', 'r') as f:
        lines = f.readlines()
    if len(lines) > ${HIST_DIRS_MAX}:
        lines = lines[-${HIST_DIRS_MAX}:]
    while curdir in lines:
        lines.remove(curdir)
    lines.append(curdir)
    with open('${HIST_DIRS_FILE}', 'w') as f:
        f.write(''.join(lines))
EOS
}
fi

add-zsh-hook chpwd cdhist

### percol
if which percol > /dev/null; then
  local percol_cmd='percol --reverse --query "$LBUFFER"'

  function percol-search-history() {
    BUFFER=$(history -n 1 | eval ${percol_cmd})
    CURSOR=$#BUFFER
    zle -R -c
  }
  zle -N percol-search-history
  bindkey '^R' percol-search-history

  function myjump() {
    local destination=$([[ -e $HIST_DIRS_FILE ]] && cat $HIST_DIRS_FILE | eval ${percol_cmd})
    [[ -n "$destination" ]] && zle -U "cd $destination"
    zle reset-prompt
  }
else
  # percol is not available, use zaw
  load_if_exists $ZDOTDIR/zaw/zaw.zsh
  zstyle ':filter-select' case-insensitive yes # Áµû„ÇäËæº„Åø„Çícase-insensitive„Å´
  bindkey '^R' zaw-history # zaw-history„Çíbindkey
  function myjump() { zaw-cdr }
fi

zle -N myjump
if [ $DOLPHIN ]
then bindkey '^L' myjump
elif [ $VIM ]
then bindkey '^L' myjump
else bindkey '^J' myjump
fi

PROJECT_HOME=$HOME/Projects
PYVENV_DIR=$HOME/.pyvenv
function mkpj() {
  local pjdir=$PROJECT_HOME/$1
  local vdir=$PYVENV_DIR/$1
  [[ -e $pjdir ]] && echo "Target project ${pjdir} already exists." && return 1
  [[ -e $vdir ]] && echo "Target venv ${vdir} already exists." && return 1
  mkdir $pjdir
  cd $pjdir
  ! which autoenv_source_parent > /dev/null 2>&1 && return 1

  # make new venv
  cat << EOF
Preparing new venv (${1}) with `python -c "import sys;print(sys.executable)"`.
EOF
  python -m venv "$vdir"
  [[ ! -e $vdir ]] && echo "Failed to make new venv" && return 1
  local activate_file=$vdir/bin/activate
  [[ ! -e $activate_file ]] && echo "Activation script $activate_file not exists" && return 1
  echo "Successfully Generated new venv. Updating pip and setuptools...."
  [[ -e $vdir/bin/pip ]] && $vdir/bin/pip install -U pip setuptools
  echo "done."

  # prepare scripts for zsh-autoenv
  cat << EOS > $pjdir/.autoenv.zsh
autostash PYVENV_NAME=${1}
[[ -e ${activate_file} ]] && echo "Activate python venv (\${PYVENV_NAME})" && source ${activate_file}
autostash PYTHONHOME=$pjdir${PYTHONHOME:+:}${PYTHONHOME}
EOS
  cat << EOS > $pjdir/.autoenv_leave.zsh
[[ -n \${VIRTUAL_ENV} ]] && echo "Deactivate python venv (\${PYVENV_NAME})" && deactivate
EOS

  # authorize new script
  if which _autoenv_authorize > /dev/null 2>&1
  then _autoenv_authorize $pjdir/.autoenv.zsh && _autoenv_authorize $pjdir/.autoenv_leave.zsh
  else echo "Failed to automatically authorize autoenv script." && return 1
  fi

  # activate new env, hook autoenv chpwd handler
  which _autoenv_chpwd_handler > /dev/null 2>&1 && _autoenv_chpwd_handler
}

function rmvenv() {
  [[ ! -n "$1" ]] && echo "arguments required." && return 1
  local vdir=$PYVENV_DIR/$1
  [[ ! -e $vdir ]] && echo "No such venv: $1 ($vdir)" && return 1
  echo -n "    Removing $vdir ......... "
  rm -r $vdir
  echo "done."
}

function _rmvenv() {
  local -a envs
  local f
  for f in ${PYVENV_DIR}/*
  do
    envs+=( $(basename $f ) )
  done
  _values 'virtual envs' ${envs[*]}
}
compdef _rmvenv rmvenv

# load machine local file
[[ -f $ZDOTDIR/.zshrc.local ]] && source $ZDOTDIR/.zshrc.local

# vim: set et ts=2 sw=2:
