#!/usr/bin/env zsh
# ============================================
#  Main Config File for ZSH
# ============================================

########## HISTORY ##########
HISTFILE=~/.histfile
DIRSTACKSIZE=1000
HISTSIZE=1000000
SAVEHIST=1000000
setopt hist_ignore_all_dups
setopt hist_reduce_blanks
setopt share_history
bindkey -e
setopt hist_verify
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^P" history-beginning-search-backward-end
bindkey "^N" history-beginning-search-forward-end
setopt noflowcontrol

######### Shell options ##########
setopt correct
setopt auto_cd
# setopt auto_pushd
# setopt pushd_ignore_dups
autoload -Uz add-zsh-hook
autoload -Uz colors && colors
# autoload -U colors && colors
autoload -Uz is-at-least
# autoload predict-on
# predict-on

# Ëâ≤Ë®≠ÂÆö
export LSCOLORS=Exfxcxdxbxegedabagacad
export LS_COLORS='di=01;34:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
export ZLS_COLORS=$LS_COLORS
export CLICOLOR=true

########## COMPLETION ##########
# http://d.hatena.ne.jp/oovu70/20120405/p1
# may not need when use zsh-completions plugin
autoload -Uz compinit && compinit -C
setopt list_packed
setopt list_types

bindkey "^[[Z" reverse-menu-complete
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*:default' menu select=2
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion:*:descriptions' format '%BCompleting%b %U%d%u'
# Ë£úÂÆåÂÄôË£ú„Å´Ëâ≤„Çí„Å§„Åë„Çã
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

########## EDIT ##########
# Set keyword
autoload -Uz select-word-style
select-word-style default
# Add word separations (-,/,=,;,@,:,{,},|,',')
zstyle ':zle:*' word-chars " -/=;@:{},|"
zstyle ':zle:*' word-style unspecified

########## ALIAS ##########
alias vi="/usr/bin/vim --noplugin"
alias :q="exit"
alias tmux="tmux -2"
alias mkdir="mkdir -p"
alias ln="ln -v"  # verbose
alias path='echo $PATH | tr -s ":" "\n"'  # pretty print path
alias gg='cd `echo ${PROJECT_ROOT:-$HOME}`'

case "${OSTYPE}" in
# Mac(Unix)
darwin*)
  export LS_OPTIONS='-FG' ;;
# Linux
linux*)
  export LS_OPTIONS='--color=auto -F' ;;
esac
[[ -f ~/.dircolors ]] && eval "`dircolors ~/.dircolors`"
alias ls="ls $LS_OPTIONS"

# Git
alias gstatus="git status -s -b"
alias pull="git pull"
alias push="git push origin"

########## PROMPT ##########
### Normal PROMPT
SIMPLE_PROMPT_MODE=0
BR=$'\n'

function _update_lprompt() {
  [[ $SIMPLE_PROMPT_MODE = 1 ]] && PROMPT="$ " && return

  if [[ -n "$VIRTUAL_ENV" ]]; then
    local icon=$'\ue235 '
    local icon="üêç"
    if [[ $OSTYPE = darwin* ]]; then
      local icon="${icon} "
    fi
    local icon="$icon"$'\ue621'"$(basename $VIRTUAL_ENV) "
  else
    local icon="üêß"
    local icon=$'\uf17c '
  fi
  if [ -n "${REMOTEHOST}${SSH_CONNECTION}" ]; then
    local icon=$'\uf023 '"$icon "
  fi

  local mark_base="‚îî‚îÄ‚û§ "
  local mark_ok="%F{green}$mark_base%f"
  local mark_ng="%F{yellow}$mark_base%f"

  local mark="%(?,$mark_ok,$mark_ng)%(!,#,)"
  local icon_color="%F{16}%(?,%K{green},%K{yellow})"
  # local icon_dash="%K{16}%(?,%F{green},%F{yellow})"$'\ue0b8 '
  local icon_dash="%K{16}%(?,%F{green},%F{yellow}) "
  PROMPT="$BR$icon_color $icon$icon_dash%F{250}%~ %k$BR$mark"
}

### RPROMPT
# get vcs info
autoload -Uz vcs_info
zstyle ':vcs_info:*' max-exports 3
zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' formats "%u%cÓÇ† %s:%b ‚îÇ%r"
zstyle ':vcs_info:*' actionformats "%u%cÓÇ† %s:%b%F{198} %m <!%a>"
zstyle ':vcs_info:*' unstagedstr "%F{214}?"
zstyle ':vcs_info:*' stagedstr "%F{087}+"
zstyle ':vcs_info:git:*' check-for-changes true
# zstyle ':vcs_info:hg:*' check-for-changes true

function _get_vcs_info() {
  # vcs_info „Åß‰Ωï„ÇÇÂèñÂæó„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Éó„É≠„É≥„Éó„Éà„ÇíË°®Á§∫„Åó„Å™„ÅÑ
  [[ -z ${vcs_info_msg_0_} ]] && return 0

  # vcs_info „ÅßÊÉÖÂ†±„ÇíÂèñÂæó„Åó„ÅüÂ†¥Âêà
  # $vcs_info_msg_0_ , $vcs_info_msg_1_ , $vcs_info_msg_2_ „Çí
  # „Åù„Çå„Åû„ÇåË°®Á§∫„Åô„Çã
  local -a messages
  [[ -n "$vcs_info_msg_0_" ]] && messages+=( "%F{white}${vcs_info_msg_0_}" )
  [[ -n "$vcs_info_msg_1_" ]] && messages+=( "%F{yellow}${vcs_info_msg_1_}" )
  [[ -n "$vcs_info_msg_2_" ]] && messages+=( "%F{red}${vcs_info_msg_2_}" )
  # Èñì„Å´„Çπ„Éö„Éº„Çπ„ÇíÂÖ•„Çå„Å¶ÈÄ£Áµê„Åó„Å¶Ê®ôÊ∫ñÂá∫Âäõ„Å∏
  echo -n ${messages[*]}
}

function _get_time() {
  local time=`date "+%H:%M:%S"$'\ue621'"%Y/%m/%d"`
  echo "$time"
}

function _update_rprompt() {
  [[ $SIMPLE_PROMPT_MODE = 1 ]] && RPROMPT="" && return
  LANG=en_US.UTF-8 vcs_info
  local gitinfo=`_get_vcs_info`
  if [[ -n ${gitinfo} ]]; then
    local rinfo=${gitinfo}
  else
    local rinfo="%F{250}`_get_time`"
  fi
  # RPROMPT="%F{016}"$'\ue0b2'"%K{016} ${rinfo} %f%k"
  RPROMPT="%K{016} ${rinfo} %f%k"
}

# Delete RPROMPT after commands
# setopt transient_rprompt
function _reupdate_rprompt() {
  if [[ $SIMPLE_PROMPT_MODE = 1 ]]; then
    # cannot early return
    RPROMPT=""
  else
    # RPROMPT="%F{234}"$'\ue0b2'"%F{246}%K{234} `_get_time` %f%k"
    RPROMPT="%F{246}%K{234} `_get_time` %f%k"
  fi
  zle .accept-line
  zle .reset-prompt
}
# show datetime at old line
zle -N accept-line _reupdate_rprompt

function _update_prompt() {
  _update_lprompt
  _update_rprompt
}

function simple_prompt() {
  SIMPLE_PROMPT_MODE=1
}

function fancy_prompt() {
  SIMPLE_PROMPT_MODE=0
}

### Enable prompt
add-zsh-hook precmd _update_prompt

# powerline (python)
# source $HOME/opt/python-3.6.2/lib/python3.6/site-packages/powerline/bindings/zsh/powerline.zsh

########## SYSTEM VARIABLES ##########
# For vim
# export COLORFGBG="15;0"

# Load file if exists
function load_if_exists() {
  [[ -f $1 ]] && source $1
}

########## Plugin Settings ##########
### zsh-completions
# http://www.slideshare.net/mollifier/zsh-3?next_slideshow=1
fpath=($HOME/.zsh/zsh-completions/src(N-/) $fpath)
load_if_exists $ZDOTDIR/git-flow-completion/git-flow-completion.zsh
### zsh-autoenv
load_if_exists $ZDOTDIR/zsh-autoenv/autoenv.zsh
### syntax highlight
# load_if_exists $ZDOTDIR/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

### pip
# pip zsh completion start
function _pip_completion {
  local words cword
  read -Ac words
  read -cn cword
  reply=( $( COMP_WORDS="$words[*]" \
             COMP_CWORD=$(( cword-1 )) \
             PIP_AUTO_COMPLETE=1 $words[1] ) )
}
compctl -K _pip_completion pip

### PythonZ
load_if_exists $HOME/.pythonz/etc/bashrc

### direnv
# which direnv > /dev/null && eval "$(direnv hook zsh)"

# „Å®„Å¶„ÇÇÈÅÖ„ÅÑ„ÄÇ„ÄÇ„ÄÇ
# http://yagays.github.io/blog/2013/05/20/zaw-zsh/
# Save cd history
# autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
# add-zsh-hook chpwd chpwd_recent_dirs
# zstyle ':chpwd:*' recent-dirs-max 5000
# zstyle ':chpwd:*' recent-dirs-default yes
# zstyle ':completion:*' recent-dirs-insert both
export HIST_DIRS_FILE=$HOME/.histdir
export HIST_DIRS_MAX=5000
function cdhist() {
  python << EOS
from os import path
curdir = path.abspath('.') + '\n'
if path.isfile('${HIST_DIRS_FILE}'):
    with open('${HIST_DIRS_FILE}', 'r') as f:
        lines = f.readlines()
    if len(lines) > ${HIST_DIRS_MAX}:
        lines = lines[-${HIST_DIRS_MAX}:]
    while curdir in lines:
        lines.remove(curdir)
    lines.append(curdir)
    with open('${HIST_DIRS_FILE}', 'w') as f:
        f.write(''.join(lines))
EOS
}
add-zsh-hook chpwd cdhist

### percol
if which percol > /dev/null; then
  local percol_cmd='percol --reverse --query "$LBUFFER"'

  function percol-search-history() {
    BUFFER=$(history -n 1 | eval ${percol_cmd})
    CURSOR=$#BUFFER
    zle -R -c
  }
  zle -N percol-search-history
  bindkey '^R' percol-search-history

  function myjump() {
    local destination=$([[ -e $HIST_DIRS_FILE ]] && cat $HIST_DIRS_FILE | eval ${percol_cmd})
    [[ -n "$destination" ]] && zle -U "cd $destination"
    zle reset-prompt
  }
else
  # percol is not available, use zaw
  load_if_exists $ZDOTDIR/zaw/zaw.zsh
  zstyle ':filter-select' case-insensitive yes # Áµû„ÇäËæº„Åø„Çícase-insensitive„Å´
  bindkey '^R' zaw-history # zaw-history„Çíbindkey
  function myjump() { zaw-cdr }
fi

zle -N myjump
if [ $DOLPHIN ]; then
  bindkey '^L' myjump
elif [ $VIM ]; then
  bindkey '^L' myjump
else
  bindkey '^J' myjump
fi

### Python Virtualenv Control ###
export WORKON_HOME=$HOME/.virtualenvs
function mkpjpy() {
  [[ -z $1 ]] && echo "Need project name." && return 1
  local pjdir_root=${PROJECT_HOME:-$HOME/Project}
  local pjdir=${pjdir_root}/$1
  [[ -e $pjdir ]] && echo "Target project ${pjdir} already exists." && return 1

  # make new project by cookiecutter
  echo "### Create project directory by cookiecutter ###"
  local cookierc=${HOME}/.cookiecutterrc
  cookiecutter --config-file ${cookierc} --no-input -o ${pjdir_root} cookiecutter-python \
    project_name=${1} project_slug=${1} \
    project_short_description="short description for this project" \
    version="0.0.1" license="MIT license"

  [[ ! -e $pjdir ]] && echo "Failed to make new project." && return 1
  cd $pjdir
}

# load machine local file
[[ -f $ZDOTDIR/.zshrc.local ]] && source $ZDOTDIR/.zshrc.local

# profiling
if (which zprof > /dev/null) ; then
  zprof
fi

# vim: set et ts=2 sw=2:
