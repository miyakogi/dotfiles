#!/usr/bin/env zsh
# ============================================
#  Prompt Setting for ZSH
# ============================================

if [[ $OSNAME == Windows ]]; then
  # Windows terminal does not have $DISPLAY
  PROMPT_SIMPLE_MODE=0
elif [[ -n $DISPLAY ]]; then
  PROMPT_SIMPLE_MODE=0
else
  PROMPT_SIMPLE_MODE=1
fi
BR=$'\n'

### set icon
# local icon="üêß"  # penguin
# local icon=$'\uf17c '  # tux ÔÖº
if [[ $OSNAME == Mac ]]; then
  _icon=$'\ue711 '  # mac Óúë
elif [[ $OSNAME == Windows ]]; then
  _icon='‚ùñ '
elif [[ $OSNAME == Ubuntu ]]; then
  _icon=$'\uf30c '  # ubuntu Ôåå
elif [[ $OSNAME == Arch ]]; then
  _icon=$'\uf300 '  # Arch ÔåÄ
else  # other linux
  _icon=$'\uf17c '  # tux ÔÖº
fi

_icon_sep=$'\ue621'  # separator Óò°
if [[ $OSNAME == Windows ]]; then
  _mark="$ "
else
  _mark="‚îî‚îÄ‚ñ∂ "
fi
_icon_color="%F{16}%(?,%K{green},%K{yellow})"
_icon_dash="%K{16}%(?,%F{green},%F{yellow}) "
# _icon_dash="%K{16}%(?,%F{green},%F{yellow})"$'\ue0b8 '

### configure lprompt
function _update_lprompt() {
  if [[ $PROMPT_SIMPLE_MODE == 1 ]]; then
    local venv
    if [[ -n "$VIRTUAL_ENV" ]]; then
      venv="($(basename $VIRTUAL_ENV))"
    fi
    PROMPT="${venv}[%~]$BR$ "
    return
  fi

  _cols=`tput cols`
  if [[ $OSNAME == Windows ]] && [[ $TERM != cygwin ]]; then
    _cols=$(($_cols / 2))
  fi
  _sep=`repeat $_cols printf ‚îÄ`
  _separator="%F{238}$_sep%f"

  if [[ -n "$VIRTUAL_ENV" ]]; then
    # local icon=$'\ue235 '  # python Óàµ
    local icon="üêç"  # snake
    if [[ $OSTYPE = darwin* ]]; then
      local icon="${icon} "
    fi
    local icon="$icon$_icon_sep$(basename $VIRTUAL_ENV) "
  else
    local icon=$_icon
  fi

  if [ -n "${REMOTEHOST}${SSH_CONNECTION}" ]; then
    local ssh_icon=$'\uf023'  # ÔÄ£
    local icon="$ssh_icon $_icon_sep $icon "
  fi

  local mark="%(?,%F{green}$_mark%f,%F{yellow}$_mark%f)%(!,#,)"
  PROMPT="$_separator$BR$_icon_color $icon$_icon_dash%F{250}%~ %k$BR$mark"
}

### RPROMPT
### get vcs info
autoload -Uz vcs_info
zstyle ':vcs_info:*' max-exports 3
zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' formats "%u%cÓÇ† %s:%b ‚îÇ%r"
zstyle ':vcs_info:*' actionformats "%u%cÓÇ† %s:%b%F{198} %m <!%a>"
zstyle ':vcs_info:*' unstagedstr "%F{214}?"
zstyle ':vcs_info:*' stagedstr "%F{087}+"
zstyle ':vcs_info:git:*' check-for-changes true
# zstyle ':vcs_info:hg:*' check-for-changes true

function _get_vcs_info() {
  # not prompt if vcs_info get nothing
  [[ -z ${vcs_info_msg_0_} ]] && return 0

  # if get info by vcs_info, show $vcs_info_msg_0_, $vcs_info_msg_1_ and $vcs_info_msg_2_
  local -a messages
  [[ -n "$vcs_info_msg_0_" ]] && messages+=( "%F{white}${vcs_info_msg_0_}" )
  [[ -n "$vcs_info_msg_1_" ]] && messages+=( "%F{yellow}${vcs_info_msg_1_}" )
  [[ -n "$vcs_info_msg_2_" ]] && messages+=( "%F{red}${vcs_info_msg_2_}" )
  # Return to stdout with spaces on each info
  echo -n ${messages[*]}
}

function _get_time() {
  local time=`date "+%H:%M:%S"$'\ue621'"%Y/%m/%d"`
  echo "$time"
}

### configure rprompt
function _update_rprompt() {
  [[ $PROMPT_SIMPLE_MODE = 1 ]] && RPROMPT="" && return
  LANG=en_US.UTF-8 vcs_info
  local gitinfo="`_get_vcs_info`"
  if [[ -n ${gitinfo} ]]; then
    local rinfo=${gitinfo}
  else
    local rinfo="%F{250}`_get_time`"
  fi
  # RPROMPT="%F{016}"$'\ue0b2'"%K{016} ${rinfo} %f%k"
  RPROMPT="%K{016} ${rinfo} %f%k"
}

# Delete RPROMPT after commands
# setopt transient_rprompt
function _reupdate_rprompt() {
  if [[ $PROMPT_SIMPLE_MODE = 1 ]]; then
    # cannot early return
    RPROMPT=""
  else
    RPROMPT="%F{246}%K{234} `_get_time` %f%k"
  fi
  zle .accept-line
  zle .reset-prompt
}
# show datetime at old line
zle -N accept-line _reupdate_rprompt

function _update_prompt() {
  _update_lprompt
  _update_rprompt
}

function prompt_simple() {
  PROMPT_SIMPLE_MODE=1
}

function prompt_fancy() {
  PROMPT_SIMPLE_MODE=0
}

### Enable prompt
add-zsh-hook precmd _update_prompt

# vim: set et ts=2 sw=2:
