set encoding=utf-8
scriptencoding utf-8
" if has('vim_starting') | set nocompatible | endif

" =========================================================
"     **** ViM Configuration for Linux and Windows ****
" =========================================================

" ======== encoding ======== {{{
set termencoding=utf-8
set fileencodings=ucs-bom,utf-8,cp932,iso-2022-jp,euc-jp,default,latin
set fileformats=unix,dos,mac
set shellslash  " Necessary for windows
"}}}

" ======== Startup ======== {{{
augroup myvimrc
  autocmd!
augroup END

" https://gist.github.com/1518874
if has('vim_starting') && has('reltime')
  let g:startuptime = reltime()
endif

" Set python3 path
if has('nvim')
  " set python3 path for neovim
  if has('win32') || has('win64')
    " for windows python installed by scoop
    let g:python3_host_prog = $HOME . '\scoop\shims\python3.EXE'
  elseif has('mac')
    " for mac's python installed by homebrew
    let g:python3_host_prog = '/usr/local/bin/python'
  elseif has('unix')
    " for linux
    let g:python3_host_prog = '/usr/bin/python'
  endif
else
  if has('win32') || has('win64')
    " set python3 dll path for windows
    set pythonthreedll=$HOME/scoop/apps/python/current/python39.dll
  endif
endif
"}}}

" ======== Environment variables ======== {{{
if has('vim_starting')
  function! s:addpath_if_exists(path)
    let l:path = expand(a:path)
    let l:sep = has('win32') ? ';' : ':'
    if isdirectory(l:path) || filereadable(l:path)
      let $PATH = l:path . l:sep . $PATH
    endif
  endfunction
endif
"}}}

" ============================================
"  Default Plugin Settings {{{
" ============================================
" ======== disable default plugins ========
let g:loaded_gzip = 1
let g:loaded_LogiPat = 1
let g:loaded_netrwPlugin = 1
let g:loaded_rrhelper = 1
let g:loaded_tarPlugin = 1
let g:loaded_vimballPlugin = 1
let g:loaded_zipPlugin = 1
let g:MyColorScheme = (has('win32') || has('win64')) ? 'srcery' : 'tender'
"}}}

" ============================================
"  Set Filetypes{{{
" ============================================
" ======== detect filetypes ========
if filereadable(expand('~/.vim/config/filetype.vim'))
  source ~/.vim/config/filetype.vim
endif
filetype plugin indent on
"}}}

" ============================================
"  User setting start {{{
" ============================================

" ======== System setting ========
set autoread
autocmd myvimrc WinEnter * checktime

set backupdir=~/.vim/backup
set noundofile
set noswapfile
set hidden " Hide closed buffer
set wildmenu " Enable command extension in command mode
set wildmode=longest:full,full
" Enable selecting out-of-line region in blockwise-visual mode
set virtualedit+=block

autocmd myvimrc BufEnter * setlocal formatoptions-=o
autocmd myvimrc BufEnter * setlocal formatoptions-=r
" Don't insert space when connect lines with multi-byte chars
autocmd myvimrc BufEnter * setlocal formatoptions+=M
" Improve joining comment lines
autocmd myvimrc BufEnter * setlocal formatoptions+=j

set nrformats-=octal
set nojoinspaces " Do not enter two spaces when join lines end with '.'.
" Add # to the word split condition
" autocmd myvimrc FileType vim setlocal iskeyword-=#
set textwidth=0 " no word wrapping
set backspace=indent,eol,start " Delete indent/line-breaks by BS/<C-w>
set wildignore&  " A file that matches with one of these patterns is ignored
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.bak,*.?~,*.??~,*.???~,*.~      " Backup files
set wildignore+=*.pyc                            " Python byte code

if !has('win32') && !has('mac')
  language en_US.UTF-8
endif
set keywordprg=:help
set helplang& helplang=ja,en

set notimeout
set ttimeout
set ttimeoutlen=50

set completeopt+=menu,menuone,noselect,noinsert
set completeopt-=preview " Disable previewwindow in completion
set completeopt-=longest " Disable vim's longest match
set previewheight=10 " Maximum height of the preview window.
set pumheight=16 " Maximum height of pupup menu in completion
set diffopt=filler,vertical

set visualbell t_vb=
set noerrorbells

" pythonx version setting
if !has('nvim')
  set pyxversion=3
endif

" ======== Mouse setting ========
set mouse=a
" set mousefocus
set mousehide
set mousemodel=popup

" ======== Display setting ========
set scrolloff=5 " min lines of up/bottom of cursor
set sidescrolloff=5 " min cols of left/right of cursor
set display=lastline " show all line as poossible
set wrap " wrap long line.
set nonumber " show line number column
set showcmd " show some command in the end of cmd win
set report=2
set noruler
set nospell " Disable spell check
set spelllang+=cjk " Disable spell check on multibyte characters
set spelloptions+=camel " Enable spell check for camel case words
set list " Display invisible chars
set listchars=tab:\|\ ,trail:_
set fillchars+=vert:â”ƒ
set shiftround
set nolinebreak
" '\xe2\x86\xaa' â†ª                            |
" '\xe2\x9e\x9f' âžŸ                            |
" '\xe2\x9e\xa0' âž                             |
" '\xe2\x9e\xa5' âž¥                            |
" '\xe2\xa4\xb7' â¤·                            |
" '\xe2\x9f\xbf' âŸ¿                            |
" '\xe2\xae\xa9' â®©                            |
" '\xe2\xae\x93' â®“                            |
" '\xe2\x87\x89' â‡‰                            |
" '\xe2\x87\xb6' â‡¶                            |
" '\xef\xa1\x87' ï¡‡                            |
let &showbreak = "\xe2\x86\xaa  "
if v:version >= 704 && has('patch338')
  set breakindent
  " set breakindentopt=shift:1
endif
set ambiwidth=single

" ======== Window setting ========
set cmdheight=1 " Hight of the cmdline
set splitbelow " Create new window below the current window.
set splitright " Create new window below the current window.
set noequalalways " When on, all windows are automatically made the same size after split/close

" ======== Folding setting ========
set foldmethod=marker
set foldtext=MyFoldText()

function! MyFoldText()
  let line = getline(v:foldstart)
  let marker_removed = substitute(line, '{{{\d*', '', 'g') " }}}
  let marker_removed = substitute(marker_removed, '^"', " \xe2\x87\x89 ", 'g')
  let line_count = v:foldend - v:foldstart
  let lines = line_count > 1 ? ' lines' : ' line'
  let count_in_brace = substitute(marker_removed, '\s*$', ' ('.line_count.lines.') ', '')
  return count_in_brace
endfunction

" ======== Search setting ========
set ignorecase " Ignore cases in search patterns
set smartcase " When search pattern contains upper case chars, disable ignorecase
set incsearch " While typing a search pattern, highlight first match (if exists)
set hlsearch " Highlight all the patterns matched.
set history=10000 " Size of the history to save.
set nowrapscan " End the search at the end of file.

" ======== Tab and indent setting ========
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab
set nocindent
set autoindent
set smartindent

" Restrict number of columns to highlight, to impove speed
set synmaxcol=360
set lazyredraw
"}}}

" ============================================
"  User Key Binding {{{
" ============================================

" ======== Base binding ========
nmap <Space> [Space]
nnoremap [Space] <NOP>

" ======== Cursor move ========
" Move to wrap end/start of lines by cursor keys
set whichwrap=b,s,<,>,[,]
" Move to wrap end/start of lines by h,l
nnoremap h <Left>
nnoremap l <Right>
xnoremap h <Left>
xnoremap l <Right>

" Down and Up with display-lines
nnoremap <silent> j gj
nnoremap <silent> k gk
xnoremap <silent> j gj
xnoremap <silent> k gk
nnoremap <silent> gj j
nnoremap <silent> gk k
xnoremap <silent> gj j
xnoremap <silent> gk k

if has('win32')
  inoremap <silent> <UP> <C-o>k
  inoremap <silent> <DOWN> <C-o>j
elseif has('mac')
  inoremap <silent> <UP> <C-o>k
  inoremap <silent> <DOWN> <C-o>j
else
  function! FcitxUp()
    normal! k
    return ''
  endfunction
  function! FcitxDown()
    normal! j
    return ''
  endfunction
  inoremap <silent> <UP> <C-r>=FcitxUp()<CR>
  inoremap <silent> <DOWN> <C-r>=FcitxDown()<CR>
endif

" Move to start/end of lines
noremap H ^
noremap L $

" Open foldings by `l` key
if has('folding')
  nnoremap <expr><silent> l foldlevel(line('.')) ? "\<Right>zo" : "\<Right>"
endif

" Moving to parentheses
noremap ) t)
noremap ( t(

" Open QuickFix window if error exists
nnoremap [Space]c :<C-u>cwindow<CR>
" Moving on qflist
function! s:to_nearest_error(list, backward) abort
  let curpos = getpos('.')[1:2]
  call filter(a:list, '(a:backward ? -1 : 1) * ( v:val.lnum - curpos[0] ) > 0')
  if empty(a:list)
    echohl WarningMsg | echo 'No more ' . (a:backward ? 'previous': 'next') . ' item.' | echohl None
  else
    let target = get(sort(a:list), -a:backward)
    call cursor(target.lnum, target.col)
    execute foldlevel(line('.')) > 0 ? 'normal! zO' : ''
  endif
endfunction

function! JumpList(qflist, backward) abort
  let error_list = a:qflist ? getqflist() : getloclist(0)
  " if a:qflist
  if len(error_list) == 0 | return
  elseif len(error_list) == 1 | execute a:qflist ? 'cc' : 'll'
  else | call s:to_nearest_error(error_list, a:backward)
  endif
endfunction
nnoremap <silent> ]q :<C-u>call JumpList(1, 0)<CR>
nnoremap <silent> [q :<C-u>call JumpList(1, 1)<CR>
nnoremap <silent> ]e :<C-u>call JumpList(0, 0)<CR>
nnoremap <silent> [e :<C-u>call JumpList(0, 1)<CR>
" Moving next/prev diff on diff-mode
nnoremap ]d ]c
nnoremap [d [c

" ======== Cursor move (Insert/Command mode) ========
imap <C-h> <BS>

" Don't move cursor at leaving insert mode
" inoremap <silent> <Esc>  <Esc>`^
" inoremap <silent> <C-[>  <Esc>`^
" autocmd myvimrc InsertLeave * normal! `^
" set t_kl=OD

" Emacs like keybinding in insert mode.
inoremap <C-a> <C-o>_
inoremap <C-e> <End>
inoremap <C-f> <Right>
inoremap <C-b> <Left>
" Emacs like keybinding in cmd window.
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
" cnoremap <C-f> <Right>
" cnoremap <C-b> <Left>
cnoremap <C-n> <Down>
cnoremap <C-p> <Up>
cnoremap <Down> <C-n>
cnoremap <Up> <C-p>

" Better completion in cmdwin
" http://hujo.hateblo.jp/entry/2014/03/23/160512
set wildcharm=<TAB>
cnoremap <expr> <Tab> wildmenumode() ? "\<C-n>" : "\<Tab>"
cnoremap <expr> <S-Tab> wildmenumode() ? "\<C-p>" : ""

" Paren-completions using plaseholders
" let g:loaded_matchparen=1

" ======== textmanip ========
nnoremap <C-S-Up> :<C-u>move-2<CR>
nnoremap <C-S-Down> :<C-u>move+<CR>
inoremap <C-S-Up> <C-o>:<C-u>move-2<CR>
inoremap <C-S-Down> <C-o>:<C-u>move+<CR>

" ======== Window size control ========
" Window size
if has('gui_running')
  nnoremap <S-Up> <C-w>+
  nnoremap <S-Down> <C-w>-
  nnoremap <S-Right> <C-w>>
  nnoremap <S-Left> <C-w><
endif

" Key repeat hack for resizing splits, i.e., <C-w>+++- vs <C-w>+<C-w>+<C-w>-
" see: http://www.vim.org/scripts/script.php?script_id=2223
nmap + <C-w>+<SID>ws
nmap - <C-w>-<SID>ws
nmap <C-w>> <C-w>><SID>ws
nmap <C-w>< <C-w><<SID>ws
nnoremap <script> <SID>ws+ <C-w>+<SID>ws
nnoremap <script> <SID>ws- <C-w>-<SID>ws
nnoremap <script> <SID>ws> <C-w>><SID>ws
nnoremap <script> <SID>ws< <C-w><<SID>ws
nmap <SID>ws <Nop>

" ======== Tab setting ========
" Tab control
nnoremap <M-n> :<C-u>tabnew<CR>
nnoremap <Leader>n :<C-u>tabnew<CR>
nnoremap <M-c> :<C-u>tabclose<CR>
nnoremap <M-t> :<C-u>call g:MoveToNewTab()<CR>
nnoremap <M-Right> gt
nnoremap <M-Left> gT
nnoremap <C-j> gt
nnoremap <C-k> gT
nnoremap <C-Right> gt
nnoremap <C-Left> gT
nnoremap <S-Right> gt
nnoremap <S-Left> gT

function! g:MoveToNewTab()
  tab split
  tabprevious
  if winnr('$') > 1
    close
  elseif bufnr('$') > 1
    buffer #
  endif
  tabnext
endfunction

" Always show tab line
set showtabline=2
" Use text-based tabs also in gvim
" set guioptions-=e
set guioptions=

" ======== Tips ========
" from å®Ÿè·µVim
xnoremap . :normal .<CR>
" Enter command mode by Q instead of exec mode
nnoremap Q q:

" Repeat previous substitution with same flag
" When want to change flag, use `:& [flags]`
nnoremap & :&&<CR>
vnoremap & :&&<CR>

" Leader setting of macvim
if has('mac')
  map _ <Leader>
endif

" <C-@> is too close to <C-[> and danger on jp keyboard
inoremap <C-@> <C-[>
xnoremap <C-@> <C-[>
vnoremap <C-@> <C-[>
cnoremap <C-@> <C-[>
onoremap <C-@> <C-[>
snoremap <C-@> <C-[>
lnoremap <C-@> <C-[>

" `ZZ` and `ZQ` is too dangerous
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>

" Disable help
nnoremap <F1> <NOP>

" Disable `S`
nnoremap S <NOP>

" Bug fix of Y
nnoremap Y y$

" Improve redo
nnoremap U <C-r>

" Paste/Copy/Cut from clipboard
inoremap <C-v> <C-o>:set paste<CR><C-r>+<C-o>:set nopaste<CR>
inoremap <A-v> <C-v>
inoremap <C-z> <C-v>
cnoremap <C-v> <C-r>+
cnoremap <A-v> <C-v>
cnoremap <C-z> <C-v>
xnoremap <C-c> "+y
xnoremap <C-x> "+d
xnoremap <C-v> "+p

" Set undo points <C-w> and <C-u>
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>
inoremap <C-k> <C-g>u<C-\><C-o>D

" ======== From mswin.vim ========
" Use CTRL-Q to do what CTRL-V used to do
noremap <C-Q> <C-V>

" ======== Command mapping ========
" Clear highlighting search word -> moved to
nnoremap <silent> <ESC><ESC> :<C-u>nohl<CR><C-l>
nnoremap <silent> <C-l> :<C-u>nohl<CR><C-l>

" Normal mode additional mappings
nnoremap [Space]ss :<C-u>setlocal spell!<CR>
nnoremap [Space]d :<C-u>vertical diffsplit<Space>

" ======== CmdWin ========
" Close command line window with q
autocmd myvimrc CmdwinEnter * nnoremap <buffer> <nowait> q <C-w>c
autocmd myvimrc CmdwinEnter * startinsert
autocmd myvimrc CmdwinEnter * setlocal nonumber

"}}}

" ============================================
"  User Abbreviations {{{
" ============================================
" Abbreviations in isert modes.
"  -> Moved to after/plugin/abolish.vim
"}}}

" ============================================
"  User Script Command {{{
" ============================================

" Move previous cursor position when open a file
autocmd myvimrc BufRead * if line("'\"") > 0 && line("'\"") <= line("$") |
  \ exe "normal g`\"" | endif

" ======== Close current buffer keepig the window ========
" from http://nanasi.jp/articles/vim/kwbd_vim.html
:command! Q let kwbd_bn= bufnr("%")|enew|exe "bdel ".kwbd_bn|unlet kwbd_bn

" ======== Generate Ctags ========
command! Ctags call Ctags()
function! Ctags()
  " let ctags_target = input('Ctags: ', '')
  if &filetype ==# 'tex' || &filetype ==# 'bib'
    let ctags_target = '*.tex *.bib'
  else
    let ctags_target = '*.' . expand('%:e')
  endif
  if ctags_target !=# ''
    call system('cd '. expand('%:h') . '&&ctags ' . ctags_target )
  endif
endfunction

" ======== Clear all trailing whitespaces ========
command! RemoveTrailingSpases call RemoveTrailingSpases()
function! RemoveTrailingSpases()
  let l:p = getpos('.')
  %global/\m\s\+$/substitute/\m\s\+$//e
  call setpos('.', l:p)
endfunction

"}}}

" ============================================
"  Terminal settings {{{
" ============================================
if !has('gui_running')
  " True color support!!!
  if has('termguicolors')
    set t_8f=[38;2;%lu;%lu;%lum
    set t_8b=[48;2;%lu;%lu;%lum
    set termguicolors
  endif
  set t_Co=256

  " Use vsplit mode
  " http://qiita.com/kefir_/items/c725731d33de4d8fb096
  if has('vim_starting') && has('vertsplit') && 0
    function! g:EnableVsplitMode()
      " enable origin mode and left/right margins
      let &t_CS = 'y'
      let &t_ti = &t_ti . '\e[?6;69h'
      let &t_te = '\e[?6;69l' . &t_te
      let &t_CV = '\e[%i%p1%d;%p2%ds'
      call writefile([ '\e[?6h\e[?69h' ], '/dev/tty', 'a')
    endfunction

    " old vim does not ignore CPR
    map <special> <Esc>[3;9R <Nop>

    " new vim can't handle CPR with direct mapping
    map <expr> [3;3R g:EnableVsplitMode()
    set t_F1=[3;3R
    map <expr> <t_F1> g:EnableVsplitMode()
    let &t_RV .= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
  endif

  function! MyTermInit()
    map <Nul> <C-Space>
    xmap <Nul> <C-Space>
    smap <Nul> <C-Space>
    map! <Nul> <C-Space>
    " if exists(':ConoLineColorDark')
    "   ConoLineColorDark
    " endif
  endfunction

  " change the cursor shape depending on mode
  " see: http://vim.wikia.com/wiki/Change_cursor_shape_in_different_modes
  if has('win32unix')
    " http://koturn.hatenablog.com/entry/2013/08/13/020116
    let &t_ti .= "\e[1 q"
    let &t_SI .= "\e[5 q"
    let &t_EI .= "\e[1 q"
    let &t_ti .= "\e[0 q"
  elseif has('unix') || has('mac')
    if exists('$KONSOLE_PROFILE_NAME') || exists('$ITERM_PROFILE')
      " For konsole/yakuake or iTerm2
      let &t_SI = "\<Esc>]50;CursorShape=1\x7"
      let &t_SR = "\<Esc>]50;CursorShape=2\x7"
      let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    else
      " For other terminal
      let &t_SI = "\<Esc>[5 q"
      let &t_SR = "\<Esc>[3 q"
      let &t_EI = "\<Esc>[1 q"
    endif
    if exists('$TMUX')
      let &t_SI = "\<Esc>Ptmux;\<Esc>" . &t_SI . "\<Esc>\\"
      let &t_SR = "\<Esc>Ptmux;\<Esc>" . &t_SR . "\<Esc>\\"
      let &t_EI = "\<Esc>Ptmux;\<Esc>" . &t_EI . "\<Esc>\\"
    endif
  endif

  if $TERM == 'alacritty' && !has('nvim')
    set ttymouse=sgr
  endif

  autocmd myvimrc VimEnter * call MyTermInit()
endif
"}}}

" ============================================
"  Filetype Dependent Settings {{{
" ============================================
let python_no_builtin_highlight = 1
"}}}

" ============================================
"  Input Method Comntrol {{{
" ============================================

" Automatically disable IM when leaved insert mode
if executable('fcitx5-remote')
  autocmd myvimrc InsertLeave * call system('pgrep fcitx5 && fcitx5-remote -c')
else
  autocmd myvimrc InsertLeave * call system('xdotool key Muhenkan')
endif

"}}}

" ============================================
"  Plugin settings  {{{
" ============================================

function! IsInstalled(name) abort
  if !has('nvim')
    return match(&runtimepath, a:name) > 0
  endif

  " currently I don't use NeoVim on Windows, so don't need to care Windows Path here
  if !get(g:, '_nvim_runtimepath')
    let g:_nvim_runtimepath = glob('~/.config/nvim/pack/*/start/*')
  endif
  return match(g:_nvim_runtimepath, a:name) > 0
endfunction

" ======== neomru ======== {{{
let g:neomru#file_mru_limit = 300 " Number of files saved in file_mru
let g:neomru#file_mru_ignore_pattern = (
  \ '\~$\|\.\%(o\|exe\|dll\|bak\|sw[po]\)$'
  \)
"}}}

" ======== Signify ======== {{{
let g:signify_sign_overwrite=1
let g:signify_vcs_list = ['git']
if has('gui_running')
  " let g:signify_sign_add = 'âœš'
  " let g:signify_sign_change = 'âœ”'
  " let g:signify_sign_delete = 'âœ˜'
  let g:signify_sign_add = '+'
  let g:signify_sign_change = '~'
  let g:signify_sign_delete = 'x'
else
  let g:signify_sign_add = '+'
  let g:signify_sign_change = '~'
  let g:signify_sign_delete = 'x'
endif
"}}}

" ======== visualstar ======== {{{
let g:visualstar_no_default_key_mappings = 1
"}}}

" ======== Deoplete ======== {{{
let g:deoplete#enable_at_startup = 1 " Use deoplete
" }}}

" ======== NeoSnippets ======== {{{
let g:neosnippet#snippets_directory=[
      \ '~/.vim/snippets',
      \]
"}}}

" ======== Tcomment ======== {{{
" let g:tcommentMaps = 0
let g:tcomment_mapleader1 = ''
let g:tcomment_mapleader2 = ''
let g:tcomment_opleader1 = 'gc'  " gcb[text-obj] map may be useful
let g:tcomment_textobject_inlinecomment = ''
let g:tcomment_mapleader_uncomment_anyway = ''
"}}}

" ======== surround.vim ======== {{{
let g:surround_no_mappings = 1
" Original insertmode mapping
let g:surround_no_insert_mappings = 1
"}}}

" ======== delimitMate ======== {{{
let g:delimitMate_expand_space = 1
let g:delimitMate_expand_inside_quotes = 0
let g:delimitMate_expand_cr = 1
let g:delimitMate_smart_matchpairs = '^\%(\w\|\!\|Â£\|\$\|_\\s*\S\)'
augroup myvimrc
  autocmd FileType html,css,htmljinja,markdown let b:delimitMate_matchpairs = "(:),[:],{:},<:>"
  autocmd FileType javascript,dart,vue let b:delimitMate_matchpairs = "(:),[:],{:}"
  autocmd FileType tex,latex,plaintex let b:delimitMate_quotes = "\" ' ` $"
  autocmd FileType htmljinja,markdown let b:delimitMate_quotes = "\" ' ` %"
  autocmd FileType python let b:delimitMate_nesting_quotes = ['"',"'"]
  autocmd FileType markdown let b:delimitMate_nesting_quotes = ["`"]
  autocmd FileType nim let b:delimitMate_nesting_quotes = ['"']
  autocmd FileType htmljinja let b:delimitMate_expand_space = 1
  autocmd FileType htmljinja let b:delimitMate_expand_inside_quotes = 1
  autocmd FileType htmljinja let b:delimitMate_expand_cr = 1
  autocmd FileType python let b:delimitMate_expand_cr = 1
  autocmd FileType rust let b:delimitMate_quotes = '" ` |'
  autocmd FileType rust let b:delimitMate_expand_inside_quotes = 1
augroup END
"}}}

" ======== TextObj-User ======== {{{
let g:textobj_wiw_no_default_key_mappings=1
"}}}

" ======== Rainbow parentheses ======== {{{
let g:rainbow_parentheses_disable_filetypes=['html', 'htmljinja', 'xml', 'css']
let g:rbpt_colorpairs = [
  \ ['196', '#ff0000'],
  \ ['168', '#d7875f'],
  \ ['154', '#afff00'],
  \ ['39',  '#00afff'],
  \ ['214', '#ffb000'],
  \ ['211', '#ff97bf'],
  \ ['220', '#ffd700'],
  \ ['248', '#aaaaaa'],
  \ ]
"}}}

" ======== indentLine ========{{{
" let g:indentLine_char = 'â”‚'
let g:indentLine_char = 'âŽ¸'
let g:indentLine_concealcursor = ''
let g:indentLine_faster = 1
"}}}

" ======== vimquickrun ======== {{{
" Default config
let g:quickrun_config = {}
let g:quickrun_config['_'] = {
      \ 'runner': has('nvim') ? 'system' : 'job',
      \ 'runner/job/updatetime': 10,
      \ 'outputter/buffer/split': ':botright 13sp',
      \ 'outputter/buffer/running_mark': 'running quickrun.........',
      \ }

" ======== python ========
let g:quickrun_config['pytest'] = {
      \ 'command': 'py.test',
      \ 'cmdopt': '-q -s -n 6',
      \ 'outputter/buffer/filetype': 'test_result',
      \ 'hook/shebang/enable': 0,
      \ }
let g:quickrun_config['py.test'] = g:quickrun_config['pytest']  " not copy, just an alias
let g:quickrun_config.pytest_verbose = copy(g:quickrun_config.pytest)
let g:quickrun_config.pytest_verbose.cmdopt = '-v -s -n 6'

let g:quickrun_config['nose'] = {
      \ 'command': 'nosetests',
      \ 'cmdopt': '--nologcapture',
      \ 'outputter/buffer/filetype': 'test_result',
      \ 'hook/shebang/enable': 0,
      \ }
let g:quickrun_config.nose_verbose = copy(g:quickrun_config.nose)
let g:quickrun_config.nose_verbose.cmdopt = '--nologcapture --verbosity=2 --nocapture'

let g:quickrun_config['python_unittest'] = {
      \ 'command': 'python',
      \ 'cmdopt': '-W ignore:*:ResourceWarning -m unittest discover',
      \ 'exec': '%c %o -p %s:t',
      \ 'outputter/buffer/filetype': 'test_result',
      \ 'hook/shebang/enable': 0,
      \ }
let g:quickrun_config.python_unittest_verbose = copy(g:quickrun_config.python_unittest)
let g:quickrun_config.python_unittest_verbose.cmdopt = g:quickrun_config.python_unittest.cmdopt . ' -v'

let g:quickrun_config.green = copy(g:quickrun_config['python_unittest'])
let g:quickrun_config.green.command = 'green'
let g:quickrun_config.green.cmdopt = '-v'
let g:quickrun_config.green_verbose = copy(g:quickrun_config.green)
let g:quickrun_config.green_verbose.cmdopt = '-vv'

" ======== Rust ========
let g:quickrun_config['cargo'] = {
      \ 'command': 'cargo',
      \ 'exec': '%c %o %a',
      \ }
let g:quickrun_config['cargo/test'] = copy(g:quickrun_config.cargo)
let g:quickrun_config['cargo/test'].cmdopt = 'test --color auto'
let g:quickrun_config['cargo/test']['outputter/buffer/filetype'] = 'cargo_test'
"}}}

" ======== vim-test ========{{{
function! TestTerminal(cmd) abort
  let curbuf = bufnr('%')
  let bufnum = bufnr('test-result-terminal')
  if (bufnum == -1)
    botright new
  else
    let winid_list = win_findbuf(bufnum)
    if len(winid_list) == 0
      botright new
    else
      call win_gotoid(winid_list[0])
    endif
  endif
  let options = {
        \ 'curwin': 1,
        \ 'term_name': 'test-result-terminal',
        \ 'term_rows': 10,
        \ }
  call term_start(['/bin/sh', '-c', a:cmd], options)
  call win_gotoid(win_findbuf(curbuf)[0])
endfunction

let g:test#custom_strategies = {'terminal': function('TestTerminal')}
let g:test#strategy = 'terminal'
let g:test#runners = {'Python': ['Green'], 'Javascript': ['VueJest']}
let g:test#python#runner = 'nose'
let g:test#python#nose#options = '--nocapture --nologcapture'
let g:test#python#pytest#options = '--quiet --capture=no'
"}}}

" ======== TagBar ======== {{{
if has('mac')
  let g:tagbar_ctags_bin = '/usr/local/bin/ctags'
endif

let g:tagbar_sort = 0  " Show tags in the order in the source file
let g:tagbar_left = 1
let g:tagbar_width = 32
let g:tagbar_indent = 1
let g:tagbar_autofocus = 1
let g:tagbar_iconchars = ['â–¸', 'â–¾']

" For markdown setting
let g:tagbar_type_markdown = {
      \ 'ctagstype' : 'markdown',
      \ 'kinds' : [
      \   'h:Headline',
      \ ],
      \ 'sort' : 0,
      \ }
"}}}

" ======== Solarized ======== {{{
let g:solarized_termcolors=256
let g:solarized_contrast='high'
"}}}

" ======== Badwolf ======== {{{
let g:badwolf_darkgutter = 1
"}}}

" ======== LightLine ======== {{{
set laststatus=2
let g:lightline_conf = $HOME . '/.vim/config/lightline_conf.vim'
if filereadable(g:lightline_conf)
  execute 'source ' . g:lightline_conf
endif
"}}}

" ======== Language Server Settings ======== {{{
function! s:on_lsp_buffer_enabled() abort
  setlocal omnifunc=lsp#complete
  nmap <buffer> gd <plug>(lsp-definition)
endfunction

augroup lsp_install
  au!
  autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END

let g:lsp_diagnostics_enabled = 0
" let g:lsp_diagnostics_echo_cursor = 1
let g:lsp_text_edit_enabled = 0
"}}}

" ======== ale ======== {{{
let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_insert_leave = 1
let g:ale_set_signs = 1
let g:ale_sign_error = 'â¤«'
let g:ale_sign_warning = 'âš '

let g:ale_pattern_options = {
      \ '\.min\.js$': {'ale_enabled': 0},
      \ 'test_.*\.py$': {'ale_linters': {'python': ['flake8']}},
      \ }

let g:ale_linters = {
      \ 'javascript': ['eslint'],
      \ 'python': ['flake8', 'mypy'],
      \ }
let g:ale_python_mypy_options = '-i'
"}}}

" ======== Jedi-vim ======== {{{
let g:jedi#auto_initialization = 0
let g:jedi#auto_vim_configuration = 0
let g:jedi#completions_enabled = 0
"}}}

" ======== pyflakes-vim ======== {{{
let g:pyflakes_use_quickfix=0
"}}}

" ========= vim-flake8 ======== {{{
let g:flake8_cmd = 'pycodestyle'
if has('mac')
  let g:flake8_cmd='/usr/local/share/python/' . g:flake8_cmd
endif
"}}}

" ======== vim-go ======== {{{
let g:go_disable_autoinstall = 1
let g:go_bin_path = expand('$GOPATH/bin')
"}}}

" ======== jscomplete ======== {{{
let g:jscomplete_use = ['dom']
"}}}

" ======== vim-json ======== {{{
let g:vim_json_syntax_conceal = 0
let g:vim_json_concealcursor = ''
"}}}

" ======== racer ======== "{{{
let g:racer_cmd = $HOME . '/.cargo/bin/racer'
"}}}

" }}}

" ============================================
"  My Plugin Settings  {{{
" ============================================

" ======== conoline.vim ======== {{{
let g:conoline_use_colorscheme_default_normal = 0
let g:conoline_use_colorscheme_default_insert = 0
let g:conoline_auto_enable = has('gui_running')
let g:conoline_color_normal_dark = 'guibg=#181818 ctermbg=234'
let g:conoline_color_insert_dark = 'guibg=#000000 ctermbg=232'
let g:conoline_color_normal_nr_dark = 'guibg=#181818 ctermbg=234'
let g:conoline_color_insert_nr_dark = 'guibg=#000000 ctermbg=232'
"}}}

" ======== seiya ======== {{{
let g:seiya_auto_enable=0
let g:seiya_target_groups = ['ctermbg', 'guibg']
"}}}

" ======== SidePanel.vim ======== {{{
let g:sidepanel_pos = 'left'
let g:sidepanel_width = 26
let g:sidepanel_config = {}
let g:sidepanel_config['nerdtree'] = {}
let g:sidepanel_config['tagbar'] = {}
let g:sidepanel_config['defx'] = {}
let g:sidepanel_use_rabbit_ui = 0
"}}}

" ======== quick-closer.vim ======== {{{
let g:quick_closer_filetypes = [
      \ 'capture',
      \ 'help',
      \ 'nerdtree',
      \ 'quickrun',
      \ 'nose_result',
      \ 'ref-pydoc',
      \ 'qf',
      \ 'netrw',
      \ ]
"}}}

" ======== livemark.vim ======== {{{
" let g:livemark_python = $HOME . '/bin/python3'
"}}}

" ======== AsyncJedi ========"{{{
let g:asyncjedi_no_detail = 1
"}}}
"}}}

" ============================================
"  Post process {{{
" ============================================

" ======== Read local settings ('~/.vimrc.local') ========
" http://vim-users.jp/2009/12/hack108/
if filereadable(expand('~/.vimrc.local'))
  source ~/.vimrc.local
endif

" ======== Load plugin settings on start up ========
if filereadable(expand('~/.vim/config/plugins.vim'))
  autocmd myvimrc VimEnter * source ~/.vim/config/plugins.vim
endif

" ======== Record and show startup time ========
if has('vim_starting') && has('reltime')
  autocmd myvimrc VimEnter * echomsg 'startuptime: ' . reltimestr(reltime(g:startuptime))
endif
"}}}

" packadd matchit
" vim set\ fdm=marker\ ts=2\ sts=2\ sw=2\ tw=0\ et
